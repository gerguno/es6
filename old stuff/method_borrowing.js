// Method Borrowing
// from https://learn.javascript.ru/call-apply

// Как мы знаем, arguments не массив, а обычный объект, поэтому таких полезных методов как push, pop, join и других у него нет. Но иногда так хочется, чтобы были…
// Нет ничего проще! Давайте скопируем метод join из обычного массива:

function printArgs() {
	arguments.join = [].join; // одолжили метод (1) join - це метод будь-якого масиву

	var argStr = arguments.join(':'); // (2)

	console.log( argStr ); // сработает и выведет 1:2:3
}

printArgs(1, 2, 3);


// …Однако, копирование метода из одного объекта в другой не всегда приемлемо!
// Представим на минуту, что вместо arguments у нас – произвольный объект. У него тоже есть числовые индексы, length и мы хотим вызвать в его контексте метод [].join. То есть, ситуация похожа на arguments, но (!) вполне возможно, что у объекта есть свой метод join.
// Поэтому копировать [].join, как сделано выше, нельзя: если он перезапишет собственный join объекта, то будет страшный бардак и путаница.

// короче, а вдруг у об'єкта arguments буде свій метод join ?

// Безопасно вызвать метод нам поможет call:

function printArgs() {
  var join = [].join; // скопируем ссылку на функцию в переменную

  // вызовем join с this=arguments,
  // этот вызов эквивалентен arguments.join(':') из примера выше
  var argStr = join.call(arguments, ':');

  alert( argStr ); // сработает и выведет 1:2:3
}

printArgs(1, 2, 3);